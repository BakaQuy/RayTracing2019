#include "mathematicaltransmitterproduct.h"
MathematicalTransmitterProduct::MathematicalTransmitterProduct(int posX, int posY) : QPointF(posX, posY)
{
    m_type              = "Transmitter";
    m_zone              = buildCoverage();
    m_frequency         = 26e9;
    m_bandwidth         = 100e6;
    m_row               = 1;
    m_column            = 1;
    m_orientation       = 0;
    m_pr_orientation    = 0;
    lambda              = c / m_frequency;
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // !!!!!!!!!!!!!!!!                                      !!!!!!!!!!!!!
    // !!!!!!!!!!!!!!!! Relative Permittivity is on the wall !!!!!!!!!!!!!
    // !!!!!!!!!!!!!!!!                                      !!!!!!!!!!!!!
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    epsilonWallRel      = 4.5;
}

MathematicalTransmitterProduct::~MathematicalTransmitterProduct()
{
    cout << "Mathematical Transmitter Product Deleted." << endl;
}


void MathematicalTransmitterProduct::appendTree(MathematicalTreeProduct *tree)
{
    m_trees.push_back(tree);
}


void MathematicalTransmitterProduct::drawRays()
{

}


QPolygonF MathematicalTransmitterProduct::buildCoverage()
{
    QPolygonF coverage;
    for (int i = 0; i < 16; i++) {
        coverage << QPointF(x() + m_radius * cos(M_PI * i / 8), y() + m_radius * sin(M_PI * i / 8));
    }
    return coverage;
}

complex<double>
MathematicalTransmitterProduct::computeImpulseReflection(vector<MathematicalRayProduct *> *ray_line)
{
    complex <double> i(0.0, 1.0);
    int amountSegment = ray_line->size();
    double completeLength = 0.0;
    double R = 1;
    MathematicalRayProduct *current_ray;

    for (int i = 0; i < amountSegment; i++) {
        current_ray = ray_line->at(i);
        if (i != amountSegment - 1) {
            double thetaI = abs(current_ray->getTetai());
            R *= computeReflexionPer(thetaI, epsilonWallRel);
        }
        completeLength += current_ray->getMeterLength();
    }
    double a = R / completeLength;

    // Angle in degrees
    double angle_transmitter = ray_line->back()->angle();
    complex<double> array_factor = totaleArrayFactor(angle_transmitter, 90);
    double tau = completeLength/c;

    complex<double> impulse_r = a * array_factor
                                * exp(-i * (2.0 * M_PI / lambda) * completeLength)
                                * exp(-i * 2.0*M_PI * std::complex<double>(m_frequency * tau));
    return impulse_r;
}

complex <double> MathematicalTransmitterProduct::computeEMfield(vector<MathematicalRayProduct *> *rayLine,
                                                               ProductObservable *receiver)
{
    //  One vector<ray*> is one multi-path componant, the size of the vector determine the n-level
    //  we are in, for each ray only the power in the last ray is transmitted to
    //  the receptor. As seen in the power formula, n rays -> n-1 additions to the power.

    //  This function gives the electrical field, generated by one MPC, at the receiver.
    //  The electric field is // to the dipole antenna since we only consider relections
    //  off the buildings. The electric field is not // for the reflexion with the ground
    //  though. This is taken into account in the function computePrx.


    complex <double> i(0.0, 1.0);
    int amountSegment = rayLine->size();
    double completeLength = 0.0;
    double R = 1;
    complex <double> Efield = 0.0;
    MathematicalRayProduct *currentRay;

    for (int i = 0; i < amountSegment; i++) {
        currentRay = rayLine->at(i);
        // Take angle between the ray and the x axis > 0
        if (i != amountSegment - 1) {

            //  The last segment, the one that reach the receptor does not have a rebound
            double thetaI = abs(currentRay->getTetai());
            R *= computeReflexionPer(thetaI, epsilonWallRel);
        }

        //  Get each length of each ray segment after the meter conversion (1px == 1dm)
        completeLength += currentRay->getMeterLength();

    }

    double Ia = sqrt(2.0 * m_power / Ra); // Ia could be changed for Beamforming application (add exp)
    double a = R / completeLength;

    // Angle in degrees
    double angle_receiver = rayLine->front()->angle();
    double angle_transmitter = rayLine->back()->angle();

    m_receiver_speed.translate(-m_receiver_speed.p1());
    m_ray_speed.translate(-m_ray_speed.p1());
    QLineF resultant_speed(QPointF(0.0,0.0),m_receiver_speed.p2()-m_ray_speed.p2());
    double shift = (angle_receiver - resultant_speed.angle()) * M_PI/180.0;
//    cout << "Angle received: " << angle_receiver << endl;
//    cout << "Angle Receiver: " << m_receiver_speed.angle() << endl;
//    cout << "Angle Ray: " << m_ray_speed.angle() << endl;
//    cout << "Speed resultant: " << m_ray_speed.length()*3.6 << endl;
//    cout << "Shift: " << angle_receiver - resultant_speed.angle() << endl;
    Efield = i * ((Zvoid * Ia) * a * exp(-i * (2.0 * M_PI / lambda) * completeLength) / (2.0 * M_PI));
    complex<double> array_factor = totaleArrayFactor(angle_transmitter, 90);
    Efield *= array_factor;

    if (amountSegment == 1) {

        // Adding the ground component
        complex <double> groundEfield = this->computeEfieldGround(receiver,angle_transmitter); // Compute the electrical field from the ray reflected off the ground
        Efield += groundEfield;
        m_los_factor[receiver] = pow(abs(a),2);

    } else {

        m_nlos_factor[receiver] += pow(abs(a),2);

    }

    QPointF p1 = rayLine->at(rayLine->size()-1)->p2();
    //if (p1.x() - 1 != this->getPosX() && p1.y() != this->getPosY()) {
        vector<double> point(2);
        point[0] = p1.x();
        point[1] = p1.y();
        double tau = completeLength/c;
        m_attenuation[receiver][point] = a*array_factor*exp(-i * 2.0*M_PI * std::complex<double>(m_frequency * tau));
        m_tau[receiver][point] = tau;
        m_dopplershift[receiver][point] = -2.0*M_PI * resultant_speed.length() * cos(shift) / lambda;
    return Efield;
}

complex <double>
MathematicalTransmitterProduct::computeImpulseGroundReflection(ProductObservable *copy_receiver, double direction)
{
    double distance = this->distance(copy_receiver);
    double thetaG = atan((distance / 2) / antennaHeight);
    double thetaI = M_PI - thetaG;
    double R = computeReflexionPar(thetaG, epsilonWallRel);
    double completeLength = sqrt(4*pow(antennaHeight,2)+pow(distance,2));
    complex <double> i(0.0, 1.0);
    double a = R  / completeLength;
    complex<double> array_factor = totaleArrayFactor(direction,thetaI*180.0/M_PI);
    double tau = completeLength/c;
    complex<double> impulse_r = a * array_factor
                                * exp(-i * (2.0 * M_PI / lambda) * completeLength)
                                * exp(-i * 2.0*M_PI * std::complex<double>(m_frequency * tau));
    return impulse_r;
}

complex <double> MathematicalTransmitterProduct::computeEfieldGround(ProductObservable *receiver, double direction)
{
    // Compute the electrical field, at the receiver, induced by the ray reflected off the ground.
    // To Do: check if there is a wall between the TX and RX
    double distance = this->distance(receiver); // conversion (1px == 2cm)
    double thetaG = atan((distance / 2) / antennaHeight);
    double thetaI = M_PI - thetaG;
    double R = computeReflexionPar(thetaG, epsilonWallRel);
    double completeLength = sqrt(4*pow(antennaHeight,2)+pow(distance,2)); //distance / sin(thetaG);

    complex <double> i(0.0, 1.0);
    double Ia = sqrt(2 * m_power / Ra); // Ia could be changed for Beamforming application
    double a = R  / completeLength;
    complex<double> array_factor = totaleArrayFactor(direction,thetaI*180.0/M_PI);
    complex <double> Efield = i * a * (Zvoid * Ia) * array_factor * exp(-i*(2.0*M_PI/lambda)*completeLength) / (2*M_PI);
    vector<double> point(2);
    point[0] = 0;
    point[1] = 0;
    double tau = completeLength/c;
    double shift = (direction - m_receiver_speed.angle()) * M_PI/180.0;
    m_attenuation[receiver][point] = a*exp(-i * 2.0*M_PI * std::complex<double>(m_frequency * tau));
    m_tau[receiver][point] = tau;
    m_nlos_factor[receiver] += pow(abs(a),2);
    m_dopplershift[receiver][point] = -2.0*M_PI * m_receiver_speed.length() * cos(shift) * cos(M_PI/2-thetaG) / lambda;

    return Efield;
}


double MathematicalTransmitterProduct::distance(ProductObservable *receiver)
{

    //
    //  For display, it calcultes the direct Euclidian distance from the receiver
    //  to the emettor, displays the results on the UI
    //

    double x1 = x();
    double y1 = y();
    double x2 = receiver->getPos()->x();
    double y2 = receiver->getPos()->y();

    return sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2)) * px_to_meter; // conversion (1px == 1dm)
}

complex<double>
MathematicalTransmitterProduct::computeImpulseDiffraction(vector<MathematicalRayProduct *> *ray_line)
{
    double direct_dist = sqrt(pow(ray_line->at(1)->p1().x() - ray_line->at(0)->p2().x(), 2)
                              + pow(ray_line->at(1)->p1().y() - ray_line->at(0)->p2().y(), 2)); //convertir px to cm?
    complex<double> F = 0.0;
    complex <double> i(0.0, 1.0);

    // The length defference between the path going through the tip of the obstacle, and the direct path.
    double delta_r = (ray_line->at(0)->length() + ray_line->at(1)->length() - direct_dist) * px_to_meter;
    double nu = sqrt(2 * 2 * M_PI / lambda * delta_r / M_PI);

    // The ITU's approximation for |F(nu)|^2
    double absF = pow(10, -6.9 / 40) / sqrt((sqrt(pow(nu - 0.1, 2) + 1) + nu - 0.1));
    double argF = -M_PI / 4 - pow(nu, 2) * M_PI / 2;
    F = absF * exp(i * argF);

    Line *directRay = new Line(ray_line->at(0)->p2(), ray_line->at(1)->p1());
    double angle = ray_line->at(1)->angle();
    double tau = (ray_line->at(0)->getMeterLength()+ray_line->at(1)->getMeterLength())/c;
    complex<double> array_factor = totaleArrayFactor(angle,90);

    complex<double> impulse_r = array_factor*F
                                *exp(-i*(2.0*M_PI / lambda)*directRay->getMeterLength())
                                *exp(-i * 2.0*M_PI * std::complex<double>(m_frequency * tau))
                                /directRay->getMeterLength();
    return impulse_r;
}

complex<double>
MathematicalTransmitterProduct::computeDiffractedEfield(vector<MathematicalRayProduct *> *rayLine)
{

    // Direct distance between the receiver and the transmitter
//    double direct_dist = sqrt(pow(transmitter->getPosition().x()-m_Receiver->getPosX(),2)
//                              + pow(transmitter->getPosition().y()-m_Receiver->getPosY(),2)); //convertir px to cm?

    double direct_dist = sqrt(pow(rayLine->at(1)->p1().x() - rayLine->at(0)->p2().x(), 2)
                              + pow(rayLine->at(1)->p1().y() - rayLine->at(0)->p2().y(), 2)); //convertir px to cm?

    complex<double> Efield = 0.0;
    complex<double> F = 0.0;
    complex <double> i(0.0, 1.0);

    // The length defference between the path going through the tip of the obstacle, and the direct path.

    double delta_r = (rayLine->at(0)->length() + rayLine->at(1)->length() - direct_dist) * px_to_meter;

    double nu = sqrt(2 * 2 * M_PI / lambda * delta_r / M_PI);
    // The ITU's approximation for |F(nu)|^2

    double absF = pow(10, -6.9 / 40) / sqrt((sqrt(pow(nu - 0.1, 2) + 1) + nu - 0.1));
    double argF = -M_PI / 4 - pow(nu, 2) * M_PI / 2;
    F = absF * exp(i * argF);

    Line *directRay = new Line(rayLine->at(0)->p2(), rayLine->at(1)->p1());
    double angle = rayLine->at(1)->angle();
    complex<double> array_factor = totaleArrayFactor(angle,90);
    cout << "Angle diffraction: " << angle << endl;
    double Ia = sqrt(2 * m_power / Ra); // Ia could be changed for Beamforming application (add exp)
    Efield = -i  * ((Zvoid * Ia) / (2 * M_PI)) * array_factor
             * (exp(-i * (2.0 * M_PI / lambda) * directRay->getMeterLength())
                / directRay->getMeterLength());
    Efield = F * Efield;
    delete directRay;
    return Efield;
}


complex<double> MathematicalTransmitterProduct::computeDiffractedTreeEfield(vector<QLineF> rayLine)
{

    // Direct distance between the receiver and the transmitter

    double direct_dist = sqrt(pow(rayLine.at(1).p1().x() - rayLine.at(0).p2().x(), 2)
                              + pow(rayLine.at(1).p1().y() - rayLine.at(0).p2().y(), 2)); //convertir px to cm?

    complex<double> Efield = 0.0;
    complex<double> F = 0.0;
    complex <double> i(0.0, 1.0);

    // The length defference between the path going through the tip of the obstacle, and the direct path.

    double delta_r = (rayLine.at(0).length() + rayLine.at(1).length() - direct_dist) * pow(10, -1.0);

    double nu = sqrt(2 * 2 * M_PI / lambda * delta_r / M_PI);
    // The ITU's approximation for |F(nu)|^2

    double absF = pow(10, -6.9 / 40) / sqrt((sqrt(pow(nu - 0.1, 2) + 1) + nu - 0.1));
    double argF = -M_PI / 4 - pow(nu, 2) * M_PI / 2;
    F = absF * exp(i * argF);

    Line *directRay = new Line(rayLine.at(0).p2(), rayLine.at(1).p1());

    double Ia = sqrt(2 * m_power / Ra); // Ia could be changed for Beamforming application (add exp)
    Efield = -i  * ((Zvoid * Ia) / (2 * M_PI)) *
             (exp(-i * (2.0 * M_PI / lambda) * directRay->getMeterLength()) / directRay->getMeterLength());
    Efield = F * Efield;
    delete directRay;
    return Efield;
}


vector<vector<QLineF> >
MathematicalTransmitterProduct::buildTreeRays(QPointF *Rx, MathematicalTreeProduct *tree)
{

    //
    //  Construct the diffracted rays around the tree
    //
    //  Rx: receivers position
    //

    float radius = tree->getRadius();
    QPointF treeCenter;
    treeCenter.setX(tree->getPosX());
    treeCenter.setY(tree->getPosY());

    // The direct path is used in order to build a tree square model perpendicualr to the path
    QLineF directPath(*this, *Rx);
    directPath.setAngle(directPath.angle() + 90);
    directPath.translate(treeCenter - *this);
    directPath.setLength(radius);

    directPath.setAngle(directPath.angle() + 45);
    QPointF treeCorner1 = directPath.p2();

    directPath.setAngle(directPath.angle() + 90);
    QPointF treeCorner2 = directPath.p2();

    directPath.setAngle(directPath.angle() + 90);
    QPointF treeCorner3 = directPath.p2();

    directPath.setAngle(directPath.angle() + 90);
    QPointF treeCorner4 = directPath.p2();

    QLineF distance1;
    QLineF distance2;

    distance1.setPoints(*this, treeCorner1);
    distance2.setPoints(*this, treeCorner4);

    vector<vector<QLineF>> wholeRays;
    vector<QLineF> wholeRay1;
    vector<QLineF> wholeRay2;
    vector<QLineF> wholeRay3;

    if (distance1.length() < distance2.length()) {


        //          Rx
        //
        //      4 ----- 3
        //      |       |
        //      |       |
        //      1 ----- 2
        //
        //          Tx


        wholeRay1.push_back(distance1);
        wholeRay1.push_back(QLineF(treeCorner1, treeCorner4));
        wholeRay1.push_back(QLineF(treeCorner4, *Rx));

        wholeRays.push_back(wholeRay1);

        wholeRay2.push_back(QLineF(*this, treeCorner2));
        wholeRay2.push_back(QLineF(treeCorner2, treeCorner3));
        wholeRay2.push_back(QLineF(treeCorner3, *Rx));

        wholeRays.push_back(wholeRay2);

        // Top ray

        QPointF edge1;
        directPath.setPoints(*this, *Rx);
        directPath.intersect(distance1, &edge1);

        QPointF edge2;
        directPath.intersect(distance2, &edge2);

        QLineF firstDiffractedRay(*this, edge1);
        QLineF lastDiffractedRay(*this, edge2);

        // Correct the lenght of the first and last diffractrd rays
        wholeRay3.push_back(firstDiffractedRay);
        wholeRay3.push_back(QLineF(edge1, edge2));
        wholeRay3.push_back(lastDiffractedRay);

    } else {


        //         Rx
        //
        //     2 ----- 1
        //     |       |
        //     |       |
        //     3 ----- 4
        //
        //         Tx


        wholeRay1.push_back(QLineF(distance2));
        wholeRay1.push_back(QLineF(treeCorner4, treeCorner1));
        wholeRay1.push_back(QLineF(treeCorner1, *Rx));

        wholeRays.push_back(wholeRay1);

        wholeRay2.push_back(QLineF(*this, treeCorner3));
        wholeRay2.push_back(QLineF(treeCorner3, treeCorner2));
        wholeRay2.push_back(QLineF(treeCorner2, *Rx));

        wholeRays.push_back(wholeRay2);

        // Top ray

        QPointF edge1;
        directPath.setPoints(*this, *Rx);
        directPath.intersect(distance2, &edge1);

        QPointF edge2;
        directPath.intersect(distance1, &edge2);

        QLineF firstDiffractedRay(*this, edge2);
        QLineF lastDiffractedRay(*this, edge1);

        // Correct the lenght of the first and last diffractrd rays
        wholeRay3.push_back(firstDiffractedRay);
        wholeRay3.push_back(QLineF(edge2, edge1));
        wholeRay3.push_back(lastDiffractedRay);
    }
    return wholeRays;
}


void MathematicalTransmitterProduct::computeRayThroughTree(QPointF *Rx, MathematicalTreeProduct *tree)
{
    vector<vector<QLineF>> wholeRays = buildTreeRays(Rx, tree);
    for (unsigned int i = 0; i < m_wholeRays.size(); i++) {
        complex<double> EfieldTree = computeDiffractedTreeEfield(wholeRays.at(i));
    }
}


void MathematicalTransmitterProduct::chooseBeam(ProductObservable *receiver)
{

    double powerAtReceiver = 0;
    complex<double> emField = 0;
    char chosenBeam = -5;

    vector<vector<MathematicalRayProduct *>*> wholeRays = m_receiversRays[receiver];

    for (int i = -5; i < 5; i++) {
        m_pr_orientation = i;

        emField = 0;
        vector<double> receiverPowers;

        for (unsigned j = 0; j < wholeRays.size(); j++) {
            vector<MathematicalRayProduct *> *wholeRay  = wholeRays.at(j);

            if (wholeRay->at(0)->getDiffracted()) {

                //
                //      The ray is a diffracted one.
                //

                complex<double>EMfield = computeDiffractedEfield(wholeRay);
                emField += EMfield;
                double power = computePrx(EMfield);
                receiverPowers.push_back(power);

            } else {

                //
                //      The ray was reflected.
                //
                m_ray_speed = ray_speeds[wholeRay];
                m_ray_speed.setLength(m_ray_speed.length()/3.6);
                complex<double> EMfield = computeEMfield(wholeRay, receiver);
                emField += EMfield;
                double power = computePrx(EMfield);
                receiverPowers.push_back(power);

            }
        }

        if (computePrx(emField) > powerAtReceiver) {

            powerAtReceiver = computePrx(emField);
            chosenBeam = i;
            m_receiversField[receiver] = emField;
            m_receiversPowers[receiver] = receiverPowers;

        }
    }

    m_pr_orientation = chosenBeam;
    m_chosenBeams[receiver] = true;
}


void MathematicalTransmitterProduct::comput4FixedBeam(ProductObservable *receiver)
{
    bool diffracted = false;

    for (unsigned i = 0; i < m_receiversRays[receiver].size(); i++) {

        vector<MathematicalRayProduct *> *wholeRay = m_receiversRays[receiver].at(i);

        for (unsigned j = 0; j < m_receiversRays[receiver].at(i)->size(); j++) {

            if (wholeRay->at(0)->getDiffracted()) {

                //
                //      The ray is a diffracted one.
                //

                map<ProductObservable *, map<double, double>>::iterator it;

                complex<double>EMfield = computeDiffractedEfield(wholeRay);
                m_receiversField[receiver] += EMfield;
                double power = computePrx(EMfield);
                m_receiversPowers[receiver].push_back(power);

                diffracted = true;

            } else {


                //
                //      The ray was reflected.
                //

                complex<double> EMfield = computeEMfield(wholeRay, receiver);
                m_receiversField[receiver] += EMfield;
                double power = computePrx(EMfield);
                m_receiversPowers[receiver].push_back(power);

            }
        }
    }
}


void MathematicalTransmitterProduct::dontChoseBeam(ProductObservable *receiver)
{
    m_chosenBeams[receiver] = true;
}


void MathematicalTransmitterProduct::freazeBeams()
{
    m_beamsFrozen = true;
}


double MathematicalTransmitterProduct::computePrx(complex <double> totalEfield)
{
    // Compute the power at the receive antenna with the total electric field induced by all MPC

    complex <double> Voc = (lambda / M_PI) * (totalEfield);
    double Prx = 1 / (8 * Ra) * norm(Voc);
    return Prx;
}


double MathematicalTransmitterProduct::dBm(double power)
{
    return 10 * (log10(power)) + 30.0;
}


double MathematicalTransmitterProduct::computeReflexionPer(double thetaI, double epsilonR)
{
//    double R = (cos(thetaI) - sqrt(epsilonR)*sqrt(1 - (1/epsilonR)*pow(sin(thetaI),2)))
//               /(cos(thetaI) + sqrt(epsilonR)*sqrt(1 - (1/epsilonR)*pow(sin(thetaI),2)));

    //  Now in the code thatai is the angle between the ray and the wall and not between
    //  the ray and the normal to the wall.
    //  Basicly thetai = pi/2 - thetai.
    //  Because of that cos and sin are inverted and we take their absolute value because of the angles given by Qt.

    double R = (abs(sin(thetaI)) - sqrt(epsilonR) * sqrt(1 - (1 / epsilonR) * pow(cos(thetaI), 2))) /
               (abs(sin(thetaI)) + sqrt(epsilonR) * sqrt(1 - (1 / epsilonR) * pow(cos(thetaI), 2)));
    return R;
}


double MathematicalTransmitterProduct::computeReflexionPar(double thetaI, double epsilonR)
{
    double R = (cos(thetaI) - (1 / sqrt(epsilonR)) * sqrt(1 - (1 / epsilonR) * pow(sin(thetaI), 2))) /
               (cos(thetaI) + (1 / sqrt(epsilonR)) * sqrt(1 - (1 / epsilonR) * pow(sin(thetaI), 2)));
    return R;
}


vector<vector<MathematicalRayProduct *> *> MathematicalTransmitterProduct::getRays()
{
    return m_wholeRays;
}


void MathematicalTransmitterProduct::notifyObservables()
{
    for (unsigned int i = 0; i < m_productObservable.size(); i++) {
        m_productObservable.at(i)->notify();
    }
}


QPointF MathematicalTransmitterProduct::sceneRectIntersection(const QRectF &rect, const QLineF &line) const
{
    //
    //  This function takes a bounding ray (line) of the illumination zone and gives its intersection
    //  with the scene boundaries.
    //

    QLineF boundary1(rect.topLeft(), rect.bottomLeft()),
           boundary2(rect.bottomLeft(), rect.bottomRight()),
           boundary3(rect.bottomRight(), rect.topRight()),
           boundary4(rect.topRight(), rect.topLeft());

    QPointF intersectionPoint;

    if (line.intersect(boundary1, &intersectionPoint) == 1) {}
    else if (line.intersect(boundary2, &intersectionPoint) == 1) {}
    else if (line.intersect(boundary3, &intersectionPoint) == 1) {}
    else if (line.intersect(boundary4, &intersectionPoint) == 1) {}
    return intersectionPoint;
}

// Tree transmition


double MathematicalTransmitterProduct::computeElevationScaterringAngle(float heightRx,
                                                                       float heightTx,
                                                                       float heightConopy,
                                                                       float distanceRxTree)
{
    return M_PI / 2 - atan2(heightRx - (heightTx + heightConopy / 2), distanceRxTree);
}


map<string, double>
MathematicalTransmitterProduct::computeIncidenceDepartureAngles(float angleIncidenceConopy,
                                                                float angleAzimuth,
                                                                float angleElevation)
{
    map<string, double> anglesScttering;
    anglesScttering["incidenceElevation"] = acos(cos(angleElevation) * cos(angleIncidenceConopy)
                                                 - sin(angleElevation) * cos(angleAzimuth));
    return  anglesScttering;
}

void MathematicalTransmitterProduct::clearAll(){
    //map<ProductObservable *,vector<vector<MathematicalRayProduct *>*>>::iterator rays;
    vector<vector<MathematicalRayProduct*>*> whole_rays;
    vector<MathematicalRayProduct*>* tmp;
    for (const auto  &rays: m_receiversRays){
        whole_rays = rays.second;
        for (unsigned i = 0; i<whole_rays.size(); i++){
            tmp = whole_rays.at(i);
            for (unsigned j = 0; j<tmp->size();j++){
                delete tmp->at(j);
            }
            delete whole_rays.at(i);
        }
    }
    m_receiversRays.clear();
}

// ---------------------------------------------------- TransmitterProduct -------------------------------------------------------------------


void MathematicalTransmitterProduct::newProperties(QPointF new_position, double orientation)
{
    m_graphic->notifyToGraphic(&new_position, orientation);
}


// ---------------------------------------------------- MathematicalProduct -------------------------------------------------------------------
void MathematicalTransmitterProduct::setPosX(int posX) {
    setX(posX);
}
void MathematicalTransmitterProduct::setPosY(int posY) {
    setY(posY);
}

void MathematicalTransmitterProduct::update(QGraphicsItem *graphic)
{
    QPointF direction(graphic->scenePos().x() - x(), graphic->scenePos().y() - y());
    m_zone.translate(direction);
    setX(graphic->scenePos().x());
    setY(graphic->scenePos().y());
    setOrientation(graphic->rotation());
    notifyObservables();

}


void MathematicalTransmitterProduct::openDialog()
{
    new DialogTransmitterProduct(this);
}


// ---------------------------------------------------- ProductObserver -------------------------------------------------------------------


void MathematicalTransmitterProduct::update(ProductObservable *receiver,
                                            const QLineF movement)
{
    //      The trasnmitter is updated every time an receiver moves

    // Clear data corresponding to the receiver calling the update

    m_receiversField[receiver] = 0;
    m_los_factor[receiver] = 0.0;
    m_nlos_factor[receiver] = 0.0;
    m_receiversPowers[receiver].erase(m_receiversPowers[receiver].begin(), m_receiversPowers[receiver].end());
    ray_speeds.erase(ray_speeds.begin(), ray_speeds.end());
    m_attenuation.erase(receiver);
    m_tau.erase(receiver);
    m_dopplershift.erase(receiver);
    m_receiver_speed = movement;
    m_receiver_speed.setLength(m_receiver_speed.length()/3.6);
    m_ray_speed = QLineF(QPointF(0.0,0.0),QPointF(0.0,0.0));

    m_chosenBeams[receiver] = false;

    if (m_receiversRays.count(receiver)) {
        for (unsigned int i = 0; i < m_receiversRays[receiver].size(); i++) {
            for (unsigned int j = 0; j < m_receiversRays[receiver].at(i)->size(); j++) {
                delete m_receiversRays[receiver].at(i)->at(j);
            }
        }
        m_receiversRays[receiver].erase(m_receiversRays[receiver].begin(),
                                        m_receiversRays[receiver].end());
        m_receiversRays[receiver].shrink_to_fit();
    }

    QPointF *pos = receiver->getPos();

    if (m_zone.containsPoint(*pos, Qt::OddEvenFill)) {

        //      The receiver is in the illumination zone

        vector<MathematicalRayProduct *> *wholeRay = new vector<MathematicalRayProduct *>;
        QPointF m_pos(int(this->x()), int(this->y()));
        wholeRay->push_back(m_rayFactory->createRay(*this, *pos));
        m_receiversRays[receiver].push_back(wholeRay);
    }
}


//void MathematicalTransmitterProduct::updateCarPos(ProductObservable *productObservable)
//{
//    MathematicalCarProduct *car = dynamic_cast<MathematicalCarProduct *>(productObservable);

//    int idx = 0;
//    if (carInIlluminatedCars(car, &idx)) {

//        if (!m_zone.intersects(*car)) {
//            m_illuminatedCars.erase(m_illuminatedCars.begin() + idx);
//        }

//    } else {

//        if (m_zone.intersects(*car)) {
//            m_illuminatedCars.push_back(car);
//        }
//    }
//}


void MathematicalTransmitterProduct::attachObservable(ProductObservable *productObservable)
{
    m_productObservable.push_back(productObservable);
    m_chosenBeams[productObservable] = false;
}


void MathematicalTransmitterProduct::drawRays(ProductObservable *productObservable, bool draw)
{
    if (draw) {
        for (unsigned int i = 0; i < m_receiversRays[productObservable].size(); i++) {
            for (unsigned j = 0 ; j < m_receiversRays[productObservable].at(i)->size(); j++) {
                m_receiversRays[productObservable].at(i)->at(j)->draw();
            }
        }
    } else {
        for (unsigned int i = 0; i < m_receiversRays[productObservable].size(); i++) {
            for (unsigned int j = 0; j < m_receiversRays[productObservable].at(i)->size(); j++) {
                m_receiversRays[productObservable].at(i)->at(j)->erase();
            }
        }
    }
}


void MathematicalTransmitterProduct::compute(ProductObservable *receiver)
{
//    bool diffracted = false;

//    for (unsigned i = 0; i < m_receiversRays[receiver].size(); i++) {

//        vector<MathematicalRayProduct *> *wholeRay = m_receiversRays[receiver].at(i);

//        for (unsigned j = 0; j < m_receiversRays[receiver].at(i)->size(); j++) {

//            if (wholeRay->at(0)->getDiffracted()) {

//                //
//                //      The ray is a diffracted one.
//                //

//                map<ProductObservable *, map<double, double>>::iterator it;
//                it = m_pathloss.begin();
//                m_pathloss.erase(it->first);

//                complex<double>EMfield = computeDiffractedEfield(wholeRay);
//                m_receiversField[receiver] += EMfield;
//                double power = computePrx(EMfield);
//                m_receiversPowers[receiver].push_back(power);

//                diffracted = true;

//            } else {


//                //
//                //      The ray was reflected.
//                //

//                complex<double> EMfield = computeEMfield(wholeRay, receiver);
//                m_receiversField[receiver] += EMfield;
//                double power = computePrx(EMfield);
//                m_receiversPowers[receiver].push_back(power);

//            }
//        }
//    }

    if (!m_beamsFrozen && !m_chosenBeams[receiver]) {

        chooseBeam(receiver);

    } else {

        comput4FixedBeam(receiver);
    }

    double totalPower = computePrx(m_receiversField[receiver]);

    double powerDBm = dBm(totalPower);

    m_algorithm->sendData(this, dynamic_cast<MathematicalProduct *>(receiver));
    receiver->answer(this, powerDBm, &m_receiversPowers[receiver], m_receiversField[receiver]);
}

std::vector<QPointF>
MathematicalTransmitterProduct::pointsForPathLoss(ProductObservable *true_receiver)
{
    map<ProductObservable *, map<double, double>>::iterator it;
    std::vector<QPointF> points;
    int number_points = 50;
    MathematicalRayProduct *direct_ray;

    if (m_receiversRays[true_receiver] .size() != 0 && m_receiversRays[true_receiver].at(0)->size() == 1)
    {
        direct_ray = m_receiversRays[true_receiver].at(0)->at(0);
        for (int i = 0; i <= number_points; i++)
        {
            points.push_back(direct_ray->pointAt(double(i) / number_points));
        }
    }
    return points;
}

double
MathematicalTransmitterProduct::computePathLossPower(ProductObservable* copy_receiver)
{
    double powerAtReceiver = 0;
    complex<double> emField = 0;

    vector<vector<MathematicalRayProduct *>*> wholeRays = m_receiversRays[copy_receiver];

    for (unsigned j = 0; j < wholeRays.size(); j++)
    {
        vector<MathematicalRayProduct *> *wholeRay  = wholeRays.at(j);
        complex<double> EMfield = computeEMfield(wholeRay, copy_receiver);
        emField += EMfield;
    }
    double totalPower = computePrx(emField);

    powerAtReceiver = dBm(totalPower);

    return powerAtReceiver;
}

complex<double> MathematicalTransmitterProduct::computeInterference(ProductObservable* copy_receiver)
{
    complex<double> impulse_r = 0;
    vector<vector<MathematicalRayProduct *>*> wholeRays = m_receiversRays[copy_receiver];

    for (unsigned j = 0; j < wholeRays.size(); j++)
    {
        vector<MathematicalRayProduct *> *wholeRay  = wholeRays.at(j);

        if (wholeRay->at(0)->getDiffracted())
        {
            impulse_r += computeImpulseDiffraction(wholeRay);
        }
        else
        {
            int amountSegment = wholeRay->size();
            if (amountSegment == 1)
            {
                double angle_transmitter = wholeRay->back()->angle();
                impulse_r += computeImpulseGroundReflection(copy_receiver, angle_transmitter);
            }
            impulse_r += computeImpulseReflection(wholeRay);
        }
    }
    return impulse_r;
}

// ---------------------------------------------------- ModelObserver -------------------------------------------------------------------


void MathematicalTransmitterProduct::attachObservable(ModelObservable *modelObservable)
{
    m_model = modelObservable;
}


// ---------------------------------------------------- AbstractAntenna ---------------------------


void MathematicalTransmitterProduct::notifyParent(ProductObservable *receiver,
                                                  QLineF const movement,
                                                  const QPointF &point,
                                                  vector<MathematicalRayProduct *> *wholeRay)
{

    //
    //      Called by the transmitter images and the diffraction points.
    //

    MathematicalRayProduct *newRay = m_rayFactory->createRay(*this, point);
    wholeRay->push_back(newRay);
    m_receiversRays[receiver].push_back(wholeRay);
    ray_speeds[wholeRay] = movement;
    //m_receiver_speed = movement.length();
    //m_receiver_orientation = movement.angle();

}


void MathematicalTransmitterProduct::notifyCarDetected()
{
//    emit detectsCar(this);
}


QPointF MathematicalTransmitterProduct::getPosition() const
{
    return *this;
}


QPolygonF MathematicalTransmitterProduct::getIlluminationZone(const QRectF &rect) const
{
    return QPolygonF(rect);
}


QPolygonF MathematicalTransmitterProduct::getIlluminationZone() const
{
    return m_zone;
}


QPolygonF MathematicalTransmitterProduct::getIlluminatedZone() const
{
    return m_zone;
}


void MathematicalTransmitterProduct::setIlluminatedZone(const QPolygonF &zone)
{
    m_zone = zone;
}


void MathematicalTransmitterProduct::carMoved(MathematicalCarProduct *car,
                                              int x, int y,
                                              double orientation)
{
    if (m_zone.intersects(*car)) {

        emit detectsCar(this);
    }
}
